<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CSC 235 – Brooklyn Museum Art Gallery Game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }

    #hud {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      color: #f5f5f5;
      text-shadow: 0 0 4px #000;
      display: flex;
      gap: 24px;
      align-items: center;
      font-size: 15px;
    }

    #darkOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0);
      pointer-events: none;
      z-index: 9;
      transition: background 0.12s linear;
    }

    #centerOverlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
      background: radial-gradient(circle at top, rgba(10,10,25,0.9), rgba(0,0,0,0.97));
      color: #f5f5f5;
    }

    #centerPanel {
      max-width: 720px;
      padding: 20px 26px;
      border-radius: 10px;
      border: 1px solid #555;
      background: rgba(0,0,0,0.4);
      box-shadow: 0 0 25px rgba(0,0,0,0.8);
    }

    #centerPanel h1 {
      margin: 0 0 8px 0;
      font-size: 26px;
    }

    #centerPanel p {
      font-size: 14px;
      line-height: 1.4;
      margin: 6px 0;
    }

    #targetsList {
      margin: 8px 0 8px 14px;
      padding: 0;
      font-size: 14px;
    }

    #targetsList li {
      margin-bottom: 4px;
    }

    #startBtn, #restartBtn {
      margin-top: 14px;
      padding: 8px 18px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      background: #f0c46a;
      color: #231b11;
      font-weight: 600;
      font-size: 14px;
    }

    #startBtn:hover, #restartBtn:hover {
      background: #ffd98c;
    }

    #crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 12px;
      height: 12px;
      margin-left: -6px;
      margin-top: -6px;
      border-radius: 999px;
      border: 2px solid rgba(255,255,255,0.75);
      box-shadow: 0 0 5px rgba(0,0,0,0.8);
      z-index: 8;
      pointer-events: none;
    }

    a {
      color: #ffd892;
    }

    a:hover {
      color: #ffe8b7;
    }
  </style>
</head>
<body>

  <div id="hud">
    <span id="timerDisplay">Time: 03:00</span>
    <span id="progressDisplay">Collected: 0 / 3</span>
  </div>
  <div id="darkOverlay"></div>
  <div id="crosshair"></div>
  <div id="centerOverlay">
    <div id="centerPanel">
      <h1 id="centerTitle">Brooklyn Museum Night Watch</h1>
      <p id="centerText">
        You are the lone night guard in a small Brooklyn Museum gallery. Three art pieces from the museum’s
         collection have been flagged for inspection, but the power is fading. You have just a few
        minutes to locate them before the gallery goes completely dark.
      </p>
      <p style="font-weight:600; margin-top:10px; margin-bottom:4px;">Tonight’s target paintings:</p>
      <ul id="targetsList"></ul>
      <p style="font-size:12px; opacity:0.9;">
        Controls: <b>WASD</b> or <b>Arrow keys</b> to walk, hold <b>Right Mouse</b> to look around,
        and <b>Left-click</b> a painting (aim with the circle) to collect it.
        Some rooms are connected by doorways and short hallways.
      </p>
      <button id="startBtn">Start Night Shift</button>
      <button id="restartBtn" style="display:none;">Restart</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
let topDown = false;
let savedCamPos = new THREE.Vector3();
let savedYaw = 0;
let savedPitch = 0;
let savedFov = 75;

    let scene, camera, renderer;
    let wallSegments = [];
    let wallBoxes = [];
    let paintings = [];
    let raycaster = new THREE.Raycaster();
    let movementDebug = false;

    const keys = {};
    let yaw = 0;
    let pitch = 0;
    const moveSpeed = 6.0;     
    const lookSpeed = 0.002;
    let isLooking = false;      

    const GAME_DURATION = 180; 
    let gameStarted = false;
    let gameOver = false;
    let startTimeMs = 0;
    let pausedAtMs = 0;
let isPausedForMap = false;

    const totalTargets = 3;
    let targetPaintings = [];   
    let collectedCount = 0;

    const timerDisplay    = document.getElementById("timerDisplay");
    const progressDisplay = document.getElementById("progressDisplay");
    const darkOverlay     = document.getElementById("darkOverlay");
    const centerOverlay   = document.getElementById("centerOverlay");
    const centerTitle     = document.getElementById("centerTitle");
    const centerText      = document.getElementById("centerText");
    const targetsList     = document.getElementById("targetsList");
    const startBtn        = document.getElementById("startBtn");
    const restartBtn      = document.getElementById("restartBtn");

    const paintingConfigs = [
      {
        id: "painting_1",
        title: "Ichikawa Ebizo as Takemura Sadanoshin",
        url: "images/painting1.jpg",
        archiveUrl: "https://archive.org/details/brooklynmuseum-o53580-ichikawa-ebizo-as-takemura-sadanoshin",
        size: { width: 3.2, height: 4.0 }
      },
      {
        id: "painting_2",
        title: "\"Kaiyoikomachi\": A Geisha in her Lover's Room",
        url: "images/painting2.jpg",
        archiveUrl: "https://archive.org/details/brooklynmuseum-o3193-kaiyoikomachi-a-geisha-in-her-lovers",
        size: { width: 3.5, height: 4.0 }
      },
      {
        id: "painting_3",
        title: "Washing Clothes (Sentaku), from Women's Handicrafts: Models of Dexterity",
        url: "images/painting3.jpg",
        archiveUrl: "https://archive.org/details/brooklynmuseum-o53583-washing-clothes-sentaku-from-womens",
        size: { width: 3.0, height: 4.0 }
      },
      {
        id: "painting_4",
        title: "Oumayagashi, No. 105 from One Hundred Famous Views of Edo",
        url: "images/painting4.jpg",
        archiveUrl: "https://archive.org/details/brooklynmuseum-o49892-oumayagashi-no-105-from-one-hundred",
        size: { width: 3.0, height: 4.0 }
      },
      {
        id: "painting_5",
        title: "Yamashita Hana Playing with a Kitten",
        url: "images/painting5.jpg",
        archiveUrl: "https://archive.org/details/brooklynmuseum-o57939-yamashita-hana-playing-with-a-kitten",
        size: { width: 3.0, height: 4.0 }
      },
      {
        id: "painting_6",
        title: "Young Girl Crossing a Bridge after Snow: Calendar Year of the Second Year of Meiwa",
        url: "images/painting6.jpg",
        archiveUrl: "https://archive.org/details/brooklynmuseum-o54184-young-girl-crossing-a-bridge",
        size: { width: 3.0, height: 4.0 }
      },
      {
        id: "painting_7",
        title: "Beauties of the Latest Fashion Compared with the Beauty of Flowers (Tosei Bijin), from Flower Playing Cards (Hana-awase)",
        url: "images/painting7.jpg",
        archiveUrl: "https://archive.org/details/brooklynmuseum-o3858-beauties-of-the-latest-fashion",
        size: { width: 3.0, height: 4.0 }
      },
      {
        id: "painting_8",
        title: "New Years Parade of the Beauties of the Green Houses",
        url: "images/painting8.jpg",
        archiveUrl: "https://archive.org/details/brooklynmuseum-o6915-new-years-parade-of-the-beauties",
        size: { width: 3.0, height: 4.0 }
      },
      {
        id: "painting_9",
        title: "Cherry Blossom Viewing Outing",
        url: "images/painting9.jpg",
        archiveUrl: "https://archive.org/details/brooklynmuseum-o54185-cherry-blossom-viewing-outing",
        size: { width: 3.0, height: 4.0 }
      },
      {
        id: "painting_10",
        title: "Moonlight View of Tsukuda with Lady on a Balcony",
        url: "images/painting10.jpg",
        archiveUrl: "https://archive.org/details/brooklynmuseum-o67421-moonlight-view-of-tsukuda-with-lady",
        size: { width: 3.0, height: 4.0 }
      }
    ];

    function getRandomOffsets(count, min, max, spacing) {
      const offsets = [];
      let attempts = 0;

      while (offsets.length < count && attempts < 500) {
        const v = THREE.MathUtils.randFloat(min, max);
        if (offsets.every(o => Math.abs(o - v) >= spacing)) {
          offsets.push(v);
        }
        attempts++;
      }
      return offsets;
    }

    
    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function createWallpaperTexture(baseColor, stripeColor) {
      const size = 256;
      const canvas = document.createElement("canvas");
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext("2d");

      ctx.fillStyle = baseColor;
      ctx.fillRect(0, 0, size, size);

      ctx.fillStyle = stripeColor;
      for (let x = 0; x < size; x += 16) {
        ctx.fillRect(x, 0, 6, size);
      }
      ctx.globalAlpha = 0.18;
      for (let y = 0; y < size; y += 30) {
        ctx.fillRect(0, y, size, 4);
      }
      ctx.globalAlpha = 1.0;

      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(2, 2);
      return texture;
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x05070d);
      scene.fog = new THREE.Fog(0x05070d, 10, 80);

      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        200
      );
      camera.position.set(0, 1.7, 0);
      camera.rotation.order = "YXZ";

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const ambient = new THREE.AmbientLight(0xffffff, 0.35);
      scene.add(ambient);

      const floorGeo = new THREE.PlaneGeometry(80, 80);
      const floorMat = new THREE.MeshLambertMaterial({ color: 0x202124 });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);

      const ceilGeo = new THREE.PlaneGeometry(80, 80);
      const ceilMat = new THREE.MeshLambertMaterial({ color: 0x0f1014 });
      const ceiling = new THREE.Mesh(ceilGeo, ceilMat);
      ceiling.rotation.x = Math.PI / 2;
      ceiling.position.y = 6.5;
      scene.add(ceiling);

      const wallpapers = [
        createWallpaperTexture("#2e2626", "#5c3b3b"),
        createWallpaperTexture("#222835", "#3b4a66"),
        createWallpaperTexture("#2b2f24", "#4f5a38"),
        createWallpaperTexture("#2d2733", "#534163"),
        createWallpaperTexture("#2c2620", "#62503b")
      ];

createHallway(0, -10, 8, "z", wallpapers[1]); 
createHallway(0,  10, 8, "z", wallpapers[2]); 
createHallway(-10, 0, 8, "x", wallpapers[3]); 
createHallway( 10, 0, 8, "x", wallpapers[4]); 
const rooms = [];

rooms.push(createRoom(0, 0, wallpapers[0], {
  north: true,
  south: true,
  west:  true,
  east:  true,
  
  doorNorth: true,
  doorSouth: true,
  doorWest:  true,
  doorEast:  true
}));

rooms.push(createRoom(0, -20, wallpapers[1], {
  north: true,
  south: true,
  west:  true,
  east:  true,

  doorNorth: false,
  doorWest:  false,
  doorEast:  false,
  doorSouth: true   
}));

rooms.push(createRoom(0,  20, wallpapers[2], {
  north: true,
  south: true,
  west:  true,
  east:  true,

  doorSouth: false,
  doorWest:  false,
  doorEast:  false,
  doorNorth: true   
}));

rooms.push(createRoom(-20, 0, wallpapers[3], {
  north: true,
  south: true,
  west:  true,
  east:  true,

  doorNorth: false,
  doorSouth: false,
  doorWest:  false,
  doorEast:  true   
}));

rooms.push(createRoom( 20, 0, wallpapers[4], {
  north: true,
  south: true,
  west:  true,
  east:  true,

  doorNorth: false,
  doorSouth: false,
  doorEast:  false,
  doorWest:  true   
}));

      const lightPositions = [
        new THREE.Vector3(0,    5.8,  0),
        new THREE.Vector3(0,    5.8, -24),
        new THREE.Vector3(0,    5.8,  24),
        new THREE.Vector3(-24,  5.8,  0),
        new THREE.Vector3(24,   5.8,  0)
      ];
      const lightColors = [0xfff5d6, 0xffe7c4, 0xf0f3ff, 0xfbe4ff, 0xe8fff3];

      for (let i = 0; i < lightPositions.length; i++) {
        const pLight = new THREE.PointLight(lightColors[i], 1.0, 40, 2);
        pLight.position.copy(lightPositions[i]);
        pLight.castShadow = true;
        scene.add(pLight);
      }

      buildWallBoxes();

      createPaintings();
      chooseTargets();
      setTargetsUI();

      setupInput();
      window.addEventListener("resize", onWindowResize);
      document.addEventListener("keydown", function (e) {
        if (e.code === "KeyM") { // use M for bird's eye view feature
          topDown = !topDown;

          if (topDown) {
            savedCamPos.copy(camera.position);
            savedYaw = yaw;
            savedPitch = pitch;
            savedFov = camera.fov;
            isPausedForMap = true;
            pausedAtMs = performance.now();

            darkOverlay.style.background = "rgba(0,0,0,0)";

            camera.fov = 110;
            camera.updateProjectionMatrix();

            camera.position.set(0, 28, 0);
            yaw = 0;
            pitch = -Math.PI / 2 + 0.01;
            camera.rotation.set(pitch, yaw, 0);

            ceiling.visible = false;
          } else {
            if (isPausedForMap) {
                const pausedDuration = performance.now() - pausedAtMs;
                startTimeMs += pausedDuration;
            }
            isPausedForMap = false;
            camera.position.copy(savedCamPos);
            yaw = savedYaw;
            pitch = savedPitch;
            camera.rotation.set(pitch, yaw, 0);

            camera.fov = savedFov;
            camera.updateProjectionMatrix();

            ceiling.visible = true;

            darkOverlay.style.background = "";
          }
        }
      });

      animate();
    }

   function createRoom(cx, cz, wallpaperTexture, config) {
  const roomGroup = new THREE.Group();
  roomGroup.position.set(cx, 0, cz);

  const wallWidth  = 20; 
  const wallHeight = 12;
  const wallDepth  = 0.4;

  const open = config || {};
  const hasNorth = open.north !== false; 
  const hasSouth = open.south !== false; 
  const hasWest  = open.west  !== false; 
  const hasEast  = open.east  !== false; 

  const doorNorth = open.doorNorth !== false;
  const doorSouth = open.doorSouth !== false;
  const doorWest  = open.doorWest  !== false;
  const doorEast  = open.doorEast  !== false;

  const wallMat = new THREE.MeshLambertMaterial({
    map: wallpaperTexture
  });

  function createSolidWall() {
    const solidGeo = new THREE.BoxGeometry(wallWidth, wallHeight, wallDepth);
    const solidWall = new THREE.Mesh(solidGeo, wallMat);
    solidWall.position.set(0, wallHeight / 2, 0);
    solidWall.userData.isWall = true;
    return solidWall;
  }

  function createWallWithDoorway() {
    const wallGroup = new THREE.Group();
    const doorwayWidth = 5.5;
    const doorwayHeight = 5;

    const leftGeo = new THREE.BoxGeometry(
      (wallWidth - doorwayWidth) / 2,
      wallHeight,
      wallDepth
    );
    const leftWall = new THREE.Mesh(leftGeo, wallMat);
    leftWall.position.set(-(wallWidth + doorwayWidth) / 4, wallHeight / 2, 0);
    leftWall.userData.isWall = false; 
    wallGroup.add(leftWall);

    const rightGeo = new THREE.BoxGeometry(
      (wallWidth - doorwayWidth) / 2,
      wallHeight,
      wallDepth
    );
    const rightWall = new THREE.Mesh(rightGeo, wallMat);
    rightWall.position.set((wallWidth + doorwayWidth) / 4, wallHeight / 2, 0);
    rightWall.userData.isWall = false; 
    wallGroup.add(rightWall);

    const topGeo = new THREE.BoxGeometry(
      wallWidth,
      wallHeight - doorwayHeight,
      wallDepth
    );
    const topWall = new THREE.Mesh(topGeo, wallMat);
    topWall.position.set(0, (wallHeight + doorwayHeight) / 2, 0);
    topWall.userData.isWall = true; 
    wallGroup.add(topWall);

    return wallGroup;
  }

  if (hasNorth) {
    const frontWall = doorNorth ? createWallWithDoorway() : createSolidWall();
    frontWall.position.set(0, 0, -10);
    roomGroup.add(frontWall);
  }

  if (hasSouth) {
    const backWall = doorSouth ? createWallWithDoorway() : createSolidWall();
    backWall.rotation.y = Math.PI;
    backWall.position.set(0, 0, 10);
    roomGroup.add(backWall);
  }

  if (hasWest) {
    const leftWall = doorWest ? createWallWithDoorway() : createSolidWall();
    leftWall.rotation.y = Math.PI / 2;
    leftWall.position.set(-10, 0, 0);
    roomGroup.add(leftWall);
  }

  if (hasEast) {
    const rightWall = doorEast ? createWallWithDoorway() : createSolidWall();
    rightWall.rotation.y = -Math.PI / 2;
    rightWall.position.set(10, 0, 0);
    roomGroup.add(rightWall);
  }

  roomGroup.traverse((child) => {
    if (child instanceof THREE.Mesh && child.userData && child.userData.isWall) {
      wallSegments.push(child);
    }
  });

  scene.add(roomGroup);
  return roomGroup;
}

function createHallway(cx, cz, length, orientation, wallpaperTexture) {
  const hallway = new THREE.Group();
  hallway.position.set(cx, 0, cz);

  const width = 6;
  const height = 8;
  const depth = length;
  const endGap = 1.0;
  const wallLen = Math.max(0.1, depth - endGap * 2);

  const wallMat = new THREE.MeshLambertMaterial({ map: wallpaperTexture });

  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(width, depth),
    new THREE.MeshLambertMaterial({ color: 0x202124 })
  );
  floor.rotation.x = -Math.PI / 2;
  hallway.add(floor);

  const ceiling = new THREE.Mesh(
    new THREE.PlaneGeometry(width, depth),
    new THREE.MeshLambertMaterial({ color: 0x0f1014 })
  );
  ceiling.rotation.x = Math.PI / 2;
  ceiling.position.y = height;
  hallway.add(ceiling);

  const wallGeo = new THREE.BoxGeometry(wallLen, height, 0.4);

  const leftWall = new THREE.Mesh(wallGeo, wallMat);
  leftWall.position.set(-width / 2, height / 2, 0);
  leftWall.rotation.y = Math.PI / 2;
  leftWall.userData.isWall = false; 

  const rightWall = new THREE.Mesh(wallGeo, wallMat);
  rightWall.position.set(width / 2, height / 2, 0);
  rightWall.rotation.y = Math.PI / 2;
  rightWall.userData.isWall = false; 

  hallway.add(leftWall);
  hallway.add(rightWall);

  if (orientation === "x") {
    hallway.rotation.y = Math.PI / 2;
  }

  hallway.traverse(obj => {
    if (obj instanceof THREE.Mesh && obj.userData.isWall) {
      wallSegments.push(obj);
    }
  });

  scene.add(hallway);
}

function buildWallBoxes() {
  wallBoxes = [];
  const SHRINK = 0.05;

  for (const seg of wallSegments) {
    if (!seg.userData?.isWall) continue;

    seg.updateWorldMatrix(true, false);

    seg.geometry.computeBoundingBox();

    const box = seg.geometry.boundingBox.clone();
    box.applyMatrix4(seg.matrixWorld);
    box.expandByScalar(-SHRINK);

    wallBoxes.push(box);

  }
}

function createPaintings() {
  const loader = new THREE.TextureLoader();

  const shuffledConfigs = shuffleArray(paintingConfigs.slice());

  const validWalls = [
    { axis: "x", fixed: -29.6, rotY: 0 },
    { axis: "x", fixed:  29.6, rotY: Math.PI },
    { axis: "z", fixed: -29.6, rotY: Math.PI / 2 },
    { axis: "z", fixed:  29.6, rotY: -Math.PI / 2 }
  ];

  const DISPLAY_COUNT = 10;
  const spacing = 4.8;
  const wallSpan = 7.5;

  let placed = 0;

  for (const wall of shuffleArray(validWalls.slice())) {
    if (placed >= DISPLAY_COUNT) break;

    const remaining = DISPLAY_COUNT - placed;
    const countOnWall = Math.min(
      remaining,
      THREE.MathUtils.randInt(2, 3)
    );

    const offsets = getRandomOffsets(
      countOnWall,
      -wallSpan,
       wallSpan,
       spacing
    );

    for (const offset of offsets) {
      if (placed >= DISPLAY_COUNT) break;

      const cfg = shuffledConfigs[placed];

      const g = new THREE.PlaneGeometry(cfg.size.width, cfg.size.height);
      const m = new THREE.MeshLambertMaterial({ color: 0x777777 });
      const paintingMesh = new THREE.Mesh(g, m);

      const pos = new THREE.Vector3(0, 3.2, 0);

      if (wall.axis === "x") {
        pos.x = offset;
        pos.z = wall.fixed;
      } else {
        pos.x = wall.fixed;
        pos.z = offset;
      }

      paintingMesh.position.copy(pos);
      paintingMesh.rotation.y = wall.rotY;

      const nx = Math.sin(wall.rotY);
      const nz = Math.cos(wall.rotY);
      paintingMesh.position.x += nx * 0.04;
      paintingMesh.position.z += nz * 0.04;

      paintingMesh.userData = {
        id: cfg.id,
        title: cfg.title,
        archiveUrl: cfg.archiveUrl,
        isTarget: false,
        collected: false
      };

      scene.add(paintingMesh);
      paintings.push(paintingMesh);

      loader.load(cfg.url, tex => {
        paintingMesh.material.map = tex;
        paintingMesh.material.needsUpdate = true;
      });

      placed++;
    }
  }
}


    function chooseTargets() {
      if (paintings.length === 0) return;

      const indices = [];
      for (let i = 0; i < paintings.length; i++) indices.push(i);
      shuffleArray(indices);

      targetPaintings = [];
      collectedCount = 0;

      for (let i = 0; i < totalTargets && i < indices.length; i++) {
        const mesh = paintings[indices[i]];
        mesh.userData.isTarget = true;
        targetPaintings.push(mesh.userData);
      }

      updateProgressUI();
    }

    function setTargetsUI() {
      targetsList.innerHTML = "";
      for (let i = 0; i < targetPaintings.length; i++) {
        const t = targetPaintings[i];
        const li = document.createElement("li");
        const a = document.createElement("a");
        a.href = t.archiveUrl || "#";
        a.target = "_blank";
        a.rel = "noopener noreferrer";
        a.textContent = t.title || t.archiveUrl || "Link";
        li.appendChild(a);
        targetsList.appendChild(li);
      }
    }

    function updateProgressUI() {
      progressDisplay.textContent = "Collected: " + collectedCount + " / " + totalTargets;
    }

    function setupInput() {
      document.addEventListener("keydown", function (e) {
        keys[e.code] = true;
        if (e.code === "KeyB") {
          movementDebug = !movementDebug;
          console.log("movementDebug:", movementDebug);
        }
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space"].includes(e.code)) {
          e.preventDefault();
        }
      });

      document.addEventListener("keyup", function (e) {
        keys[e.code] = false;
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space"].includes(e.code)) {
          e.preventDefault();
        }
      });

      document.addEventListener("mousedown", function (e) {
        if (e.button === 2) {
          isLooking = true;
        }
        if (e.button === 0) {
          onLeftClick();
        }
      });

      document.addEventListener("mouseup", function (e) {
        if (e.button === 2) {
          isLooking = false;
        }
      });

      document.addEventListener("mousemove", function (e) {
        if (isLooking && gameStarted && !gameOver) {
          yaw   -= e.movementX * lookSpeed;
          pitch -= e.movementY * lookSpeed;

          const maxPitch = Math.PI / 2 - 0.05;
          if (pitch >  maxPitch) pitch =  maxPitch;
          if (pitch < -maxPitch) pitch = -maxPitch;

          camera.rotation.set(pitch, yaw, 0);
        }
      });

      document.addEventListener("contextmenu", function (e) {
        e.preventDefault();
      });

      window.addEventListener("resize", onWindowResize);

      startBtn.addEventListener("click", function () {
        if (!gameStarted) {
          startGame();
        }
      });

      restartBtn.addEventListener("click", function () {
        window.location.reload();
      });
    }

    function onLeftClick() {
      if (!gameStarted || gameOver) return;

      const ndc = new THREE.Vector2(0, 0);
      raycaster.setFromCamera(ndc, camera);

      const candidates = paintings.filter((p) => !p.userData.collected);
      const hits = raycaster.intersectObjects(candidates, false);

      if (hits.length > 0) {
        const mesh = hits[0].object;
        const data = mesh.userData;

        if (!data.collected) {
          if (data.isTarget) {
            data.collected = true;
            collectedCount++;
            updateProgressUI();

            mesh.material.opacity = 0.3;
            mesh.material.transparent = true;

            if (collectedCount >= totalTargets) {
              endGame(true);
            }
          } else {
          }
        }
      }
    }

    function updateMovement(delta) {
      if (!gameStarted || gameOver) return;
      if (topDown) return;

      const speed = moveSpeed * delta;

      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward); 
      forward.y = 0;
      forward.normalize();

      const right = new THREE.Vector3();
      right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

      const movement = new THREE.Vector3();

      if (keys["KeyW"]) {
        movement.add(forward);
      }
      if (keys["KeyS"]) {
        movement.sub(forward);
      }
      if (keys["KeyA"]) {
        movement.sub(right);
      }
      if (keys["KeyD"]) {
        movement.add(right);
      }

      if (movement.lengthSq() > 0) {
        movement.normalize().multiplyScalar(speed);
        const proposed = camera.position.clone().add(movement);

        const playerBox = new THREE.Box3().setFromCenterAndSize(
          new THREE.Vector3(proposed.x, 1.7, proposed.z),
          new THREE.Vector3(1.0, 2.0, 1.0)
        );

        if (movementDebug) {
          console.debug("[move-debug] camera:", camera.position.toArray());
          console.debug("[move-debug] movea", movement.toArray());
          console.debug("[move-debug] proposed:", proposed.toArray());
          console.debug("[move-debug] wallBoxes count:", wallBoxes.length);
        }

        let blocked = false;
        for (let i = 0; i < wallBoxes.length; i++) {
          if (playerBox.intersectsBox(wallBoxes[i])) {
            blocked = true;
            if (movementDebug) {
              console.debug("[move-debug] blocked by wall index:", i, "box:", wallBoxes[i]);
            }
            break;
          }
        }

        if (!blocked) {
          if (movementDebug) console.debug("[move-debug] move allowed");
          camera.position.copy(proposed);
        } else {
          if (movementDebug) console.debug("[move-debug] move blocked");
        }
      }
    }

    function updateArrowRotation(delta) {
      if (!gameStarted || gameOver) return;
      if (topDown) return;

      const rotateSpeed = 1.8; 

      if (keys["ArrowLeft"]) {
        yaw += rotateSpeed * delta;
      }
      if (keys["ArrowRight"]) {
        yaw -= rotateSpeed * delta;
      }

      camera.rotation.set(pitch, yaw, 0);
    }

    function startGame() {
      gameStarted = true;
      gameOver = false;
      startTimeMs = performance.now();

      centerOverlay.style.display = "none";
    }

    function updateTimer() {
      if (!gameStarted || gameOver) return;
      if (isPausedForMap) return;

      const now = performance.now();
      const elapsed = (now - startTimeMs) / 1000;
      const remaining = Math.max(0, GAME_DURATION - elapsed);

      const minutes = Math.floor(remaining / 60);
      const seconds = Math.floor(remaining % 60);
      const secStr = seconds < 10 ? "0" + seconds : seconds.toString();
      timerDisplay.textContent = "Time: " + minutes + ":" + secStr;

      const t = 1 - remaining / GAME_DURATION;
      const alpha = Math.min(1, t * 0.8);
      darkOverlay.style.background = "rgba(0,0,0," + alpha.toFixed(3) + ")";

      if (remaining <= 0 && !gameOver) {
        endGame(false);
      }
    }

    function endGame(victory) {
      gameOver = true;
      gameStarted = false;

      centerOverlay.style.display = "flex";
      restartBtn.style.display = "inline-block";
      startBtn.style.display = "none";
      targetsList.innerHTML = "";

      if (victory) {
        centerTitle.textContent = "You found them!";
        centerText.innerHTML =
          "You collected all three target paintings before the gallery went completely dark. " +
          "Here are the works you recovered (with their archive.org pages):";

        const ul = document.createElement("ul");
        ul.style.marginLeft = "16px";
        for (let i = 0; i < targetPaintings.length; i++) {
          const t = targetPaintings[i];
          const li = document.createElement("li");
          li.innerHTML =
            "<b>" + t.title + "</b><br>" +
            "<a href='" + t.archiveUrl + "' target='_blank'>" +
            t.archiveUrl + "</a>";
          ul.appendChild(li);
        }
        targetsList.replaceWith(ul); 
      } else {
        centerTitle.textContent = "Lights Out!";
        centerText.innerHTML =
          "The power has fully shut down and the gallery is in complete darkness.<br>" +
          "You did not collect all three paintings in time. Try another night shift?";
      }
    }

    let lastFrameTime = performance.now();

    function animate() {
      requestAnimationFrame(animate);

      const now = performance.now();
      const delta = (now - lastFrameTime) / 1000;
      lastFrameTime = now;

      updateArrowRotation(delta);

      updateMovement(delta);

      updateTimer();
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    window.addEventListener("load", init);
  </script>
</body>
</html>